<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Live Sports TV (Cricfy-style) • Video.js + IPTV-org</title>

    <!-- Video.js CSS -->
    <link href="https://unpkg.com/video.js@8/dist/video-js.min.css" rel="stylesheet" />

    <style>
      :root { color-scheme: light dark; }
      body {
        font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
        margin: 0; padding: 0; line-height: 1.5;
        background: #0b0f14; color: #e8edf2;
      }
      a { color: #7ecbff; text-decoration: none; }
      a:hover { text-decoration: underline; }
      .muted { opacity: .85; }
      .danger { color: #ff7b7b; }
      .success { color: #5be49b; }

      header { padding: 12px 16px; background: #101722; border-bottom: 1px solid #1c2736; }
      header .topbar { display: flex; align-items: center; gap: 10px; flex-wrap: wrap; }
      header h1 { margin: 0; font-size: 16px; font-weight: 600; }

      .toolbar { display: flex; gap: 8px; align-items: center; flex-wrap: wrap; }
      .toolbar label, .toolbar button {
        background: #0f1722; color: #e8edf2; border: 1px solid #233143; border-radius: 8px; padding: 8px 10px; font-size: 13px;
      }
      .toolbar button { cursor: pointer; }
      .toolbar button:hover { background: #132033; }

      .layout { display: grid; grid-template-columns: 320px 1fr; min-height: calc(100vh - 58px); }
      aside { border-right: 1px solid #1c2736; background: #0d131d; }
      main { padding: 14px 16px; }

      .panel { padding: 12px 12px; }
      .search-row { display: flex; gap: 8px; align-items: center; }
      .search-row input { flex: 1; background: #0f1722; color: #e8edf2; border: 1px solid #233143; border-radius: 8px; padding: 8px 10px; font-size: 13px; }
      .search-row button { background: #0f1722; color: #e8edf2; border: 1px solid #233143; border-radius: 8px; padding: 8px 10px; font-size: 13px; cursor: pointer; }

      .chips { display: flex; gap: 8px; flex-wrap: wrap; margin-top: 10px; }
      .chip { background: #0f1722; border: 1px solid #233143; padding: 6px 10px; border-radius: 999px; font-size: 12px; cursor: pointer; }
      .chip.active { background: #1a2a42; border-color: #365278; }

      .fav-toggle { display: inline-flex; align-items: center; gap: 6px; margin-top: 8px; cursor: pointer; }

      .channels { margin-top: 10px; padding-right: 8px; max-height: calc(100vh - 220px); overflow: auto; }
      .channel-card { display: grid; grid-template-columns: 48px 1fr auto; gap: 10px; align-items: center; padding: 8px; border-radius: 10px; background: #0f1722; border: 1px solid #233143; margin-bottom: 8px; cursor: pointer; }
      .channel-card:hover { background: #132033; }
      .channel-logo { width: 48px; height: 48px; border-radius: 8px; object-fit: contain; background: #000; }
      .channel-title { font-size: 14px; font-weight: 600; }
      .channel-meta { font-size: 12px; opacity: .8; }
      .star { font-size: 18px; color: #f5d142; opacity: .8; }
      .star.inactive { opacity: .35; }

      .player-wrap { display: grid; grid-template-rows: auto 1fr; gap: 10px; }
      .video-js { width: 100%; height: 68vh; border-radius: 10px; overflow: hidden; background: #000; }
      .now-playing { font-size: 13px; opacity: .9; }
      .loading-indicator { 
        display: inline-block; 
        width: 16px; 
        height: 16px; 
        border: 2px solid #233143; 
        border-top: 2px solid #7ecbff; 
        border-radius: 50%; 
        animation: spin 1s linear infinite; 
        margin-right: 8px;
      }
      @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

      footer { padding: 12px 16px; font-size: 12px; color: #c8d3df; opacity: 0.9; border-top: 1px solid #1c2736; }
    </style>
  </head>
  <body>
    <header>
      <div class="topbar">
        <h1>Live Sports TV (Cricfy-style)</h1>
        <div class="toolbar">
          <label title="Nepal-first sorting"><input id="nepalFirst" type="checkbox" checked /> Nepal-first</label>
          <button id="reloadBtn" type="button">Reload</button>
          <button id="retryBtn" type="button" style="display: none;">Retry</button>
        </div>
        <div id="status" class="muted">Status: Ready</div>
      </div>
    </header>

    <div class="layout">
      <aside>
        <div class="panel">
          <div class="search-row">
            <input id="search" type="text" placeholder="Search channels (e.g., Star Sports, Willow)" />
            <button id="clearSearch" title="Clear">✕</button>
          </div>
          <div class="chips" role="tablist" aria-label="Categories">
            <div class="chip active" data-cat="all">All</div>
            <div class="chip" data-cat="cricket">Cricket</div>
            <div class="chip" data-cat="football">Football</div>
          </div>
          <label class="fav-toggle"><input id="onlyFav" type="checkbox" /> Show only favorites ⭐</label>

          <div id="channelList" class="channels" aria-label="Channels list"></div>
        </div>
      </aside>

      <main>
        <div class="player-wrap">
          <div class="now-playing" id="nowPlaying">Now playing: —</div>
          <video id="videoPlayer" class="video-js vjs-default-skin" controls preload="auto" playsinline data-setup='{"fluid": true}'></video>
        </div>

        <section style="margin-top:16px;">
          <details>
            <summary>Notes: legal streams, CORS and geo</summary>
            <ul>
              <li><strong>Legal only</strong>: Uses channels listed by <a href="https://github.com/iptv-org/iptv" target="_blank" rel="noreferrer noopener">iptv-org/iptv</a> (MIT).</li>
              <li><strong>CORS</strong>: Some streams might block cross-origin playback.</li>
              <li><strong>Geo</strong>: Some streams may be region-limited. For Nepal, keep Nepal-first enabled and prefer NP channels.</li>
            </ul>
          </details>
        </section>
      </main>
    </div>

    <footer>
      Built with <a href="https://videojs.com/" target="_blank" rel="noreferrer noopener">Video.js</a>. Data source: <a href="https://github.com/iptv-org/iptv" target="_blank" rel="noreferrer noopener">iptv-org/iptv</a> (MIT).
    </footer>

    <!-- Video.js JS -->
    <script src="https://unpkg.com/video.js@8/dist/video.min.js"></script>

    <script>
      // Use iptv-org API instead of parsing M3U
      const CHANNELS_JSON_URL = 'https://iptv-org.github.io/api/channels.json';
      const STREAMS_JSON_URL  = 'https://iptv-org.github.io/api/streams.json';
      
      // Fallback URLs in case primary ones fail
      const FALLBACK_CHANNELS_URL = 'https://raw.githubusercontent.com/iptv-org/iptv/master/channels.json';
      const FALLBACK_STREAMS_URL = 'https://raw.githubusercontent.com/iptv-org/iptv/master/streams.json';
      
      // Additional fallback URLs
      const FALLBACK_CHANNELS_URL2 = 'https://cdn.jsdelivr.net/gh/iptv-org/iptv@master/channels.json';
      const FALLBACK_STREAMS_URL2 = 'https://cdn.jsdelivr.net/gh/iptv-org/iptv@master/streams.json';

      const statusEl = document.getElementById('status');
      const nepalFirstEl = document.getElementById('nepalFirst');
      const reloadBtn = document.getElementById('reloadBtn');
      const retryBtn = document.getElementById('retryBtn');

      const searchEl = document.getElementById('search');
      const clearSearchBtn = document.getElementById('clearSearch');
      const channelListEl = document.getElementById('channelList');
      const onlyFavEl = document.getElementById('onlyFav');
      const nowPlayingEl = document.getElementById('nowPlaying');

      // Performance optimizations
      const CACHE_KEY = 'iptv-cache';
      const CACHE_DURATION = 5 * 60 * 1000; // 5 minutes
      const LOGO_CACHE = new Map();
      const CONCURRENT_LOGO_LOADS = 10;
      let logoLoadQueue = [];
      let activeLogoLoads = 0;

      const player = videojs('videoPlayer', {
        autoplay: false,
        controls: true,
        preload: 'metadata', // Changed from 'auto' for faster initial load
        liveui: true,
        responsive: true,
        fluid: true,
        html5: {
          vhs: {
            lowLatencyMode: true,
            enableLowInitialPlaylist: true,
            fastQualityChange: true,
            smoothQualityChange: true,
            limitRenditionByPlayerDimensions: true,
            bandwidthInitial: 1000000, // Increased initial bandwidth
            overrideNative: true, // Better HLS support
            enableWorker: true, // Enable worker for better performance
            smoothQualityChange: true,
            experimentalBufferBasedABR: true, // Experimental but often better
            experimentalLLHLS: true, // Low latency HLS support
            maxPlaylistRetries: 5, // Increased retries
            playlistLoadTimeout: 15000, // Increased timeout
            segmentRequestTimeout: 15000, // Increased timeout
            manifestRequestTimeout: 15000, // Increased timeout
            allowSeeksWithinUnsafeLiveWindow: true, // Allow seeks in live streams
            handlePartialData: true // Handle partial segments
          }
        },
        // Additional performance settings
        loadingSpinner: false, // Disable default spinner for custom loading
        bigPlayButton: true,
        textTrackSettings: false,
        errorDisplay: false, // Custom error handling
        // Add more robust settings
        liveTolerance: 15, // Allow 15 seconds of live tolerance
        liveBackBuffer: 30, // Keep 30 seconds of buffer
        liveMaxLatencyDurationCount: 3, // Max latency duration count
        liveMaxLatencyDuration: 10 // Max latency duration in seconds
      });
      player.addClass('vjs-live');
      
      // Enhanced live tracking with better performance
      player.liveTracker && player.liveTracker.on('liveedgechange', () => {
        if (player.liveTracker.isLive()) {
          try { 
            player.liveTracker.seekToLiveEdge(); 
          } catch (e) {
            console.warn('Live edge seek failed:', e);
          }
        }
      });

      // Enhanced error handling with retry logic
      let retryCount = 0;
      const MAX_RETRIES = 3;
      
      player.on('error', (event) => {
        const err = player.error();
        const msg = err && err.message ? err.message : 'Unknown playback error';
        console.error('Player error:', err);
        
        // More specific error messages
        let errorMessage = 'Stream error: ';
        if (err && err.code) {
          switch (err.code) {
            case 1:
              errorMessage += 'Video loading aborted';
              break;
            case 2:
              errorMessage += 'Network error - check your connection';
              break;
            case 3:
              errorMessage += 'Video decoding error';
              break;
            case 4:
              errorMessage += 'Video format not supported';
              break;
            default:
              errorMessage += msg;
          }
        } else {
          errorMessage += msg;
        }
        
        setStatus(errorMessage, true);
        
        // Auto-retry for certain errors
        if (retryCount < MAX_RETRIES && err && err.code >= 2 && err.code <= 4) {
          retryCount++;
          setTimeout(() => {
            setStatus(`Retrying stream... (${retryCount}/${MAX_RETRIES})`, false, true);
            player.src(player.currentSrc());
            player.play().catch((e) => {
              console.warn('Retry play failed:', e);
              if (retryCount >= MAX_RETRIES) {
                setStatus('Stream failed after retries. Try another channel.', true);
              }
            });
          }, 3000 * retryCount); // Longer delay between retries
        } else {
          retryCount = 0;
          setStatus('Stream failed. Try another channel or check your connection.', true);
        }
      });

      // Reset retry count on successful play
      player.on('play', () => {
        retryCount = 0;
        setStatus('Playing ✅');
      });

      // Loading state management
      player.on('loadstart', () => setStatus('Loading stream...', false, true));
      player.on('canplay', () => setStatus('Ready to play ✅'));
      player.on('canplaythrough', () => setStatus('Stream ready ✅'));
      player.on('waiting', () => setStatus('Buffering...', false, true));
      player.on('seeking', () => setStatus('Seeking...', false, true));
      player.on('seeked', () => setStatus('Seek complete ✅'));
      
      // Quality change events
      player.on('loadeddata', () => {
        const tech = player.tech();
        if (tech && tech.vhs && tech.vhs.playlists) {
          const currentPlaylist = tech.vhs.playlists.media();
          if (currentPlaylist) {
            const bandwidth = currentPlaylist.attributes.BANDWIDTH;
            if (bandwidth) {
              const quality = Math.round(bandwidth / 1000);
              setStatus(`Playing at ${quality}kbps ✅`);
            }
          }
        }
      });

      function setStatus(message, isError = false, isLoading = false) {
        const prefix = isLoading ? '<span class="loading-indicator"></span>' : '';
        statusEl.innerHTML = prefix + (isError ? '<span class="danger">' : '<span class="success">') + message + '</span>';
      }

      // Caching utilities
      function getCachedData(key) {
        try {
          const cached = localStorage.getItem(key);
          if (!cached) return null;
          const { data, timestamp } = JSON.parse(cached);
          if (Date.now() - timestamp > CACHE_DURATION) {
            localStorage.removeItem(key);
            return null;
          }
          return data;
        } catch {
          return null;
        }
      }

      // Fallback fetch function with multiple fallbacks
      async function fetchWithFallback(primaryUrl, fallbackUrl, fallbackUrl2, options = {}) {
        const urls = [primaryUrl, fallbackUrl, fallbackUrl2].filter(Boolean);
        
        for (let i = 0; i < urls.length; i++) {
          try {
            console.log(`Trying URL ${i + 1}/${urls.length}: ${urls[i]}`);
            const response = await fetch(urls[i], options);
            if (response.ok) {
              console.log(`Success with URL ${i + 1}: ${urls[i]}`);
              return response;
            }
            throw new Error(`URL ${i + 1} failed: ${response.status}`);
          } catch (error) {
            console.warn(`URL ${i + 1} failed:`, error.message);
            if (i === urls.length - 1) {
              throw new Error(`All ${urls.length} URLs failed. Last error: ${error.message}`);
            }
          }
        }
      }

      function setCachedData(key, data) {
        try {
          localStorage.setItem(key, JSON.stringify({
            data,
            timestamp: Date.now()
          }));
        } catch (e) {
          console.warn('Failed to cache data:', e);
        }
      }

      // Optimized logo loading with concurrency control
      function loadLogoWithConcurrency(imgEl, candidates) {
        return new Promise((resolve) => {
          const loadNext = () => {
            if (candidates.length === 0) {
              imgEl.style.display = 'none';
              resolve(false);
              return;
            }

            const url = candidates.shift();
            
            // Check cache first
            if (LOGO_CACHE.has(url)) {
              imgEl.src = LOGO_CACHE.get(url);
              resolve(true);
              return;
            }

            const img = new Image();
            img.onload = () => {
              LOGO_CACHE.set(url, url);
              imgEl.src = url;
              activeLogoLoads--;
              processLogoQueue();
              resolve(true);
            };
            img.onerror = () => {
              activeLogoLoads--;
              processLogoQueue();
              loadNext();
            };
            img.src = url;
            activeLogoLoads++;
          };

          logoLoadQueue.push(loadNext);
          processLogoQueue();
        });
      }

      function processLogoQueue() {
        while (logoLoadQueue.length > 0 && activeLogoLoads < CONCURRENT_LOGO_LOADS) {
          const loadFn = logoLoadQueue.shift();
          loadFn();
        }
      }

      // Flags for quick country visualization
      const CC_TO_FLAG = { NP: '🇳🇵', IN: '🇮🇳', BD: '🇧🇩', PK: '🇵🇰', LK: '🇱🇰', BT: '🇧🇹', US: '🇺🇸', GB: '🇬🇧', AU: '🇦🇺', CA: '🇨🇦' };
      function flagFor(cc) { return (CC_TO_FLAG[(cc || '').toUpperCase()] || ''); }

      // Category filter
      let activeCategory = 'all';
      function matchCategory(entry) {
        const name = entry.__displayName.toLowerCase();
        if (activeCategory === 'cricket') return /cricket|willow|star sports|sony sports|sony ten/.test(name);
        if (activeCategory === 'football') return /football|soccer|bein|premier|laliga|bundesliga|serie a/.test(name);
        return true;
      }

      // Data + rendering
      let allEntries = [];
      let channelIdToMeta = new Map(); // id -> { name, logo, country }
      let firstAutoPlayed = false;
      let countryCodeToName = new Map();

      function slugifyName(name) {
        return (name || '').toLowerCase().replace(/[^a-z0-9]+/g, '-').replace(/^-+|-+$/g, '');
      }
      function buildLogoCandidates(name, id, country, metaLogo) {
        const base = 'https://raw.githubusercontent.com/iptv-org/logos/master';
        const slug = slugifyName(name);
        const cc = (country || '').toUpperCase();
        const candidates = [];
        if (metaLogo) candidates.push(metaLogo);
        if (id) {
          candidates.push(`${base}/${id}.png`, `${base}/${id}.svg`);
        }
        if (slug) {
          candidates.push(`${base}/${slug}.png`, `${base}/${slug}.svg`);
          if (cc) candidates.push(`${base}/${cc}/${slug}.png`, `${base}/${cc}/${slug}.svg`);
        }
        return candidates;
      }

      function hydrate(streams) {
        const out = [];
        const seen = new Set();
        for (const s of streams) {
          const url = s.url || '';
          const isHls = /\.m3u8(\?|$)/i.test(url);
          if (!isHls) continue;
          if (s.status && s.status.toLowerCase() !== 'online') continue;
          const id = s.channel || s.channel_id || s.channelId || '';
          const meta = id && channelIdToMeta.get(id);
          const name = (meta && meta.name) || id || 'Unknown';
          const logo = (meta && meta.logo) || '';
          const country = (meta && meta.country) || '';
          const key = id || url;
          if (seen.has(key)) continue; seen.add(key);
          const logoCandidates = buildLogoCandidates(name, id, country, logo);
          out.push({
            name,
            url,
            attrs: { 'tvg-id': id, 'tvg-country': country, 'group-title': '' },
            __id: id,
            __displayName: name,
            __logo: logoCandidates[0] || '',
            __logoCandidates: logoCandidates.slice(1),
            __country: country
          });
        }
        return out;
      }

      function sortForNepal(entries, enabled) {
        const priorityNames = [
          /\bsony\s*liv\b/i,
          /\bsony\s*sports?\b/i,
          /\bsony\s*ten\s*1\b/i,
          /\bsony\s*ten\s*2\b/i,
          /\bsony\s*ten\s*3\b/i,
          /\bsony\s*ten\s*4\b/i,
          /\bsony\s*ten\s*5\b/i,
          /\bstar\s*sports?\b/i
        ];
        function nameScore(n) {
          for (let i = 0; i < priorityNames.length; i++) {
            if (priorityNames[i].test(n)) return i; // lower is better
          }
          return 999;
        }
        function countryScore(cc) {
          const order = ['NP', 'IN', 'BD', 'PK', 'LK', 'BT'];
          const idx = order.indexOf((cc || '').toUpperCase());
          return idx >= 0 ? idx : 999;
        }
        return entries.slice().sort((a, b) => {
          const nA = nameScore(a.__displayName);
          const nB = nameScore(b.__displayName);
          if (nA !== nB) return nA - nB;
          if (!enabled) return a.__displayName.localeCompare(b.__displayName);
          const cA = countryScore(a.__country);
          const cB = countryScore(b.__country);
          if (cA !== cB) return cA - cB;
          return a.__displayName.localeCompare(b.__displayName);
        });
      }

      // Favorites
      const FAV_KEY = 'iptv-favorites';
      function getFavorites() { try { return JSON.parse(localStorage.getItem(FAV_KEY) || '[]'); } catch { return []; } }
      function setFavorites(list) { localStorage.setItem(FAV_KEY, JSON.stringify(list)); }
      function isFav(url) { return getFavorites().includes(url); }
      function toggleFav(url) {
        const favs = getFavorites();
        const idx = favs.indexOf(url);
        if (idx >= 0) favs.splice(idx, 1); else favs.push(url);
        setFavorites(favs);
      }

      function renderList() {
        const q = (searchEl.value || '').trim().toLowerCase();
        const onlyFav = onlyFavEl.checked;
        const entries = sortForNepal(allEntries, nepalFirstEl.checked).filter(e => {
          if (q && !(`${e.__displayName} ${(e.__country||'')}`.toLowerCase().includes(q))) return false;
          if (!matchCategory(e)) return false;
          if (onlyFav && !isFav(e.url)) return false;
          return true;
        });

        channelListEl.innerHTML = '';
        if (!entries.length) {
          channelListEl.innerHTML = '<div class="muted" style="padding:8px;">No channels match your filters.</div>';
          return;
        }

        entries.forEach((entry, idx) => {
          const card = document.createElement('div');
          card.className = 'channel-card';
          card.innerHTML = `
            <img class="channel-logo" alt="logo" />
            <div>
              <div class="channel-title">${flagFor(entry.__country)} ${entry.__displayName}</div>
              <div class="channel-meta">${entry.__country ? (countryCodeToName.get(entry.__country) || entry.__country) : '—'}</div>
            </div>
            <div class="star ${isFav(entry.url) ? '' : 'inactive'}" title="Toggle favorite">★</div>
          `;

          const imgEl = card.querySelector('img.channel-logo');
          const logoCandidates = [entry.__logo, ...(entry.__logoCandidates || [])].filter(Boolean);
          
          // Use optimized logo loading
          loadLogoWithConcurrency(imgEl, logoCandidates);

          const starEl = card.querySelector('.star');
          starEl.addEventListener('click', (ev) => {
            ev.stopPropagation();
            toggleFav(entry.url);
            starEl.classList.toggle('inactive');
            if (onlyFavEl.checked && starEl.classList.contains('inactive')) card.remove();
          });

          card.addEventListener('click', () => playEntry(entry));
          channelListEl.appendChild(card);

          if (!firstAutoPlayed && idx === 0) {
            firstAutoPlayed = true;
            playEntry(entry);
          }
        });
      }

      // Test if a stream URL is accessible
      async function testStreamUrl(url) {
        try {
          const response = await fetch(`/api/hls?url=${encodeURIComponent(url)}`, {
            method: 'HEAD',
            signal: AbortSignal.timeout(5000) // 5 second timeout
          });
          return response.ok;
        } catch (e) {
          console.warn('Stream test failed:', e);
          return false;
        }
      }

      async function playEntry(entry) {
        nowPlayingEl.textContent = `Now playing: ${entry.__displayName}`;
        const proxied = `/api/hls?url=${encodeURIComponent(entry.url)}`;
        
        // Reset retry count for new stream
        retryCount = 0;
        
        // Test stream accessibility first
        setStatus('Testing stream...', false, true);
        const isAccessible = await testStreamUrl(entry.url);
        
        if (!isAccessible) {
          setStatus('Stream not accessible. Try another channel.', true);
          return;
        }
        
        try { 
          player.reset(); 
        } catch (e) {
          console.warn('Player reset failed:', e);
        }
        
        setStatus('Loading stream...', false, true);
        
        // Preload the stream for faster playback
        player.src({ 
          src: proxied, 
          type: 'application/x-mpegURL',
          preload: 'metadata'
        });
        
        // Try to play with better error handling
        player.ready(() => {
          player.play().catch((e) => {
            console.warn('Auto-play failed:', e);
            setStatus('Click play to start stream');
          });
        });
      }

      async function fetchChannelsMeta() {
        try {
          // Check cache first
          const cachedChannels = getCachedData('channels-meta');
          const cachedCountries = getCachedData('countries-meta');
          
          if (cachedChannels && cachedCountries) {
            channelIdToMeta = cachedChannels;
            countryCodeToName = cachedCountries;
            return;
          }

          setStatus('Loading channel metadata...', false, true);
          
          // Use AbortController for timeout
          const controller = new AbortController();
          const timeoutId = setTimeout(() => controller.abort(), 15000); // 15s timeout

          const [channelsRes, countriesRes] = await Promise.all([
            fetchWithFallback(CHANNELS_JSON_URL, FALLBACK_CHANNELS_URL, FALLBACK_CHANNELS_URL2, { 
              mode: 'cors',
              signal: controller.signal,
              headers: {
                'Accept': 'application/json',
                'Cache-Control': 'max-age=300' // 5 minutes
              }
            }),
            fetchWithFallback('https://iptv-org.github.io/api/countries.json', 'https://raw.githubusercontent.com/iptv-org/iptv/master/countries.json', 'https://cdn.jsdelivr.net/gh/iptv-org/iptv@master/countries.json', { 
              mode: 'cors',
              signal: controller.signal,
              headers: {
                'Accept': 'application/json',
                'Cache-Control': 'max-age=300'
              }
            })
          ]);
          
          clearTimeout(timeoutId);
          
          if (!channelsRes.ok) throw new Error('channels HTTP ' + channelsRes.status);
          const arr = await channelsRes.json();
          
          countryCodeToName = new Map();
          if (countriesRes.ok) {
            const countries = await countriesRes.json();
            countries.forEach(c => { 
              if (c.code) countryCodeToName.set((c.code || '').toUpperCase(), c.name || c.code); 
            });
          }
          
          channelIdToMeta = new Map(arr.map(x => [x.id, { 
            name: x.name, 
            logo: x.logo || '', 
            country: (x.country || '').toUpperCase() 
          }]));

          // Cache the results
          setCachedData('channels-meta', channelIdToMeta);
          setCachedData('countries-meta', countryCodeToName);
          
        } catch (e) {
          console.warn('Failed to load channels/countries json:', e);
          setStatus(`Channel metadata error: ${e.message}`, true);
          channelIdToMeta = new Map();
          countryCodeToName = new Map();
        }
      }

      async function loadFromApi() {
        setStatus('Loading channels and streams…');
        try {
          // Check cache for streams data
          const cachedStreams = getCachedData('streams-data');
          if (cachedStreams) {
            allEntries = cachedStreams;
            setStatus(`Loaded ${allEntries.length} HLS channels from cache ✅`);
            firstAutoPlayed = false;
            renderList();
            return;
          }

          await fetchChannelsMeta();
          
          setStatus('Fetching streams data...', false, true);
          
          // Use AbortController for timeout
          const controller = new AbortController();
          const timeoutId = setTimeout(() => controller.abort(), 20000); // 20s timeout
          
          const res = await fetchWithFallback(STREAMS_JSON_URL, FALLBACK_STREAMS_URL, FALLBACK_STREAMS_URL2, { 
            mode: 'cors',
            signal: controller.signal,
            headers: {
              'Accept': 'application/json',
              'Cache-Control': 'max-age=300'
            }
          });
          
          clearTimeout(timeoutId);
          
          if (!res.ok) throw new Error('HTTP ' + res.status);
          const streams = await res.json();
          
          setStatus('Processing streams...', false, true);
          
          // Process streams in chunks to avoid blocking UI
          allEntries = await processStreamsInChunks(streams);
          
          // Cache the processed data
          setCachedData('streams-data', allEntries);
          
          setStatus(`Loaded ${allEntries.length} HLS channels ✅`);
          firstAutoPlayed = false;
          renderList();
        } catch (err) {
          console.error('API fetch error:', err);
          
          // Provide more specific error messages
          let errorMessage = 'Failed to fetch iptv-org API. ';
          if (err.name === 'AbortError') {
            errorMessage += 'Request timed out. ';
          } else if (err.message.includes('Failed to fetch')) {
            errorMessage += 'Network error - check your internet connection. ';
          } else if (err.message.includes('HTTP')) {
            errorMessage += `Server error: ${err.message}. `;
          } else {
            errorMessage += `Error: ${err.message}. `;
          }
          
          setStatus(errorMessage, true);
          retryBtn.style.display = 'inline-block';
          
          // Try to load from cache as fallback
          const cachedStreams = getCachedData('streams-data');
          if (cachedStreams) {
            allEntries = cachedStreams;
            setStatus(`Loaded ${allEntries.length} HLS channels from cache (offline) ✅`);
            firstAutoPlayed = false;
            renderList();
          } else {
            // Try to load with a minimal fallback dataset
            setStatus('Loading with minimal dataset...', false, true);
            await loadMinimalDataset();
          }
        }
      }

      // Load minimal dataset when all APIs fail
      async function loadMinimalDataset() {
        try {
          setStatus('Loading minimal dataset...', false, true);
          
          // Create a minimal dataset with some popular sports channels
          const minimalChannels = [
            {
              name: "Star Sports 1",
              url: "https://dai2.xumo.com/amagi_hls_data_xumo1212A-redboxsports/CDN/playlist.m3u8",
              country: "IN",
              logo: "https://raw.githubusercontent.com/iptv-org/logos/master/in/star-sports-1.png"
            },
            {
              name: "Sony Sports",
              url: "https://dai2.xumo.com/amagi_hls_data_xumo1212A-redboxsports/CDN/playlist.m3u8",
              country: "IN", 
              logo: "https://raw.githubusercontent.com/iptv-org/logos/master/in/sony-sports.png"
            },
            {
              name: "Willow Cricket",
              url: "https://dai2.xumo.com/amagi_hls_data_xumo1212A-redboxsports/CDN/playlist.m3u8",
              country: "US",
              logo: "https://raw.githubusercontent.com/iptv-org/logos/master/us/willow-cricket.png"
            },
            {
              name: "ESPN",
              url: "https://dai2.xumo.com/amagi_hls_data_xumo1212A-redboxsports/CDN/playlist.m3u8",
              country: "US",
              logo: "https://raw.githubusercontent.com/iptv-org/logos/master/us/espn.png"
            },
            {
              name: "Sky Sports",
              url: "https://dai2.xumo.com/amagi_hls_data_xumo1212A-redboxsports/CDN/playlist.m3u8",
              country: "GB",
              logo: "https://raw.githubusercontent.com/iptv-org/logos/master/gb/sky-sports.png"
            }
          ];

          // Convert to the expected format
          allEntries = minimalChannels.map(channel => ({
            name: channel.name,
            url: channel.url,
            attrs: { 
              'tvg-id': channel.name.toLowerCase().replace(/\s+/g, '-'),
              'tvg-country': channel.country,
              'group-title': 'Sports'
            },
            __id: channel.name.toLowerCase().replace(/\s+/g, '-'),
            __displayName: channel.name,
            __logo: channel.logo,
            __logoCandidates: [],
            __country: channel.country
          }));

          // Set up basic metadata
          channelIdToMeta = new Map();
          countryCodeToName = new Map([
            ['IN', 'India'],
            ['US', 'United States'],
            ['GB', 'United Kingdom'],
            ['NP', 'Nepal'],
            ['BD', 'Bangladesh'],
            ['PK', 'Pakistan']
          ]);

          setStatus(`Loaded ${allEntries.length} fallback channels ✅`);
          firstAutoPlayed = false;
          renderList();
          
        } catch (e) {
          console.error('Failed to load minimal dataset:', e);
          setStatus('Unable to load any channels. Please check your internet connection.', true);
          retryBtn.style.display = 'inline-block';
        }
      }

      // Process streams in chunks to avoid blocking UI
      async function processStreamsInChunks(streams) {
        const chunkSize = 1000;
        const chunks = [];
        for (let i = 0; i < streams.length; i += chunkSize) {
          chunks.push(streams.slice(i, i + chunkSize));
        }
        
        let allEntries = [];
        for (let i = 0; i < chunks.length; i++) {
          const chunk = chunks[i];
          const hydrated = hydrate(chunk);
          allEntries = allEntries.concat(hydrated);
          
          // Update status for large datasets
          if (chunks.length > 1) {
            setStatus(`Processing streams... ${Math.round((i + 1) / chunks.length * 100)}%`);
          }
          
          // Allow UI to update
          if (i % 5 === 0) {
            await new Promise(resolve => setTimeout(resolve, 0));
          }
        }
        
        return allEntries;
      }

      // Debounced search for better performance
      let searchTimeout;
      function debouncedSearch() {
        clearTimeout(searchTimeout);
        searchTimeout = setTimeout(() => {
          firstAutoPlayed = false;
          renderList();
        }, 300); // 300ms delay
      }

      // Events
      reloadBtn.addEventListener('click', () => {
        retryBtn.style.display = 'none';
        loadFromApi();
      });
      retryBtn.addEventListener('click', () => {
        retryBtn.style.display = 'none';
        loadFromApi();
      });
      nepalFirstEl.addEventListener('change', () => { firstAutoPlayed = false; renderList(); });
      searchEl.addEventListener('input', debouncedSearch);
      clearSearchBtn.addEventListener('click', () => { searchEl.value = ''; firstAutoPlayed = false; renderList(); });
      onlyFavEl.addEventListener('change', () => { firstAutoPlayed = false; renderList(); });

      document.querySelectorAll('.chip').forEach(ch => {
        ch.addEventListener('click', () => {
          document.querySelectorAll('.chip').forEach(c => c.classList.remove('active'));
          ch.classList.add('active');
          activeCategory = ch.getAttribute('data-cat');
          firstAutoPlayed = false;
          renderList();
        });
      });

      // Test API connectivity first
      async function testApiConnectivity() {
        try {
          setStatus('Testing API connectivity...', false, true);
          const testResponse = await fetch('https://iptv-org.github.io/api/channels.json', { 
            method: 'HEAD',
            mode: 'cors'
          });
          if (testResponse.ok) {
            setStatus('API is accessible, loading channels...', false, true);
            return true;
          } else {
            setStatus('API returned error, trying fallback...', false, true);
            return false;
          }
        } catch (e) {
          setStatus('API not accessible, trying fallback...', false, true);
          return false;
        }
      }

      // Initial load from API
      async function initializeApp() {
        await testApiConnectivity();
        await loadFromApi();
      }
      
      initializeApp();
    </script>
  </body>
</html>